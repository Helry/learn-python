# -*- coding: utf-8 -*- 

# 一个带默认参数的函数
def power(x,y = 2):
	s = 1
	while y > 0:
		y = y - 1
		s = s * x
	return s

print power(10)


# 注意：
# 虽然设置默认参数可以简化函数的调用，但是设置默认参数时，有几个注意事项：
# 1.是必选参数在前，默认参数在后，否则Python的解释器会报错?
# 二是如何设置默认参数。当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。

# 好处：最大的好处是能降低调用函数的难度。




# 递归函数
# 场景：计算n！

def fact(n):
	if n==1:
		return 1
	return n *fact(n - 1)

print fact(1)
print fact(10)

# 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。
# 注意:使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用
# ，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。


# 改进：解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。
# 尾递归是什么?尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，
# 使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。

def fact(n):
	return fact_iter(n , 1)

def fact_iter(num , product):
	if num == 1:
		return product
	return fact_iter(num - 1 , num * product)

print fact_iter(5,1)



# 使用递归函数实现移动汉诺塔 :
def move(n , a , b, c):
	if n == 1:
		print 'move' , a , '-->', c
	else : 
		move(n - 1 , a , c , b)
		move(1, a , b , c)
		move(n - 1 , b , a , c)
move(3 , 'A' , 'B' , 'C')
